##### 9.1 单独编译

将结构声明放在头文件中，修改时只需在头文件中做一次修改即可。

另外也可以将函数原型放在头文件中。

可以将原来的程序分为三部分：

- 头文件：包含结构声明和使用这些结构的函数的原型。
- 源代码文件：包含与结构有关的函数的代码。
- 源代码文件：包含调用与结构相关的函数的代码。

注意：不要将函数定义或变量声明放到头文件中。可能会在同一个程序中包含同一个函数的两个定义。

头文件中常包含：

- 函数原型。
- 使用#define或const定义的符号常量。
- 结构声明。
- 类声明。
- 模板声明。
- 内联函数。

将结构声明放在头文件中是可以的，因为它们不创建变量，而只是在源代码文件中声明结构变量时，告诉编译器如何创建该结构变量。

同样，模板声明不是将被编译的代码，它们指示编译器如何生成与源代码中的函数调用相匹配的函数定义。

被声明为const的数据和内联函数有特殊的链接属性(稍后将介绍),因此可以将其放在头文件中，而不会引起问题。


在包含头文件时，我们使用`“coordin.h"`, 而不是`<coodin.h>`，如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录(或其他目录，这取决于编译器)。如果没有在那里找到头文件，则将在标准位置查找。因此在包含自己的头文件时，应使用引号而不是尖括号。

注意，只需将源代码文件加入到项目中，而不用加入头文件。这是因为#include指令管理头文件。另外，不要使用#include来包含源代码文件，这样做将导致多重声明。



编译两个cpp：

```
g++ file1.cpp file2.cpp
```



##### 9.2 存储持续性、作用域和链接性

C++使用三种(在C++11中是四种)不同的方案来存储数据，这些方案的区别就在于数据保留在内存中的时间。

- 自动存储持续性: 在函数定义中声明的变量(包括函数参数)的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。C++有两种存储持续性为自动的变量。

- 静态存储持续性：在函数定义外定义的变量和使用关键字static 定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。C++有3种存储持续性为静态的变量。
- 线程存储持续性(C++1)：当前，多核处理器很常见，这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_ local 声明的，则其生命周期与所属的线程一样长。 本书不探讨并行编程。
- 动态存储持续性：用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储(free store)或堆(heap)。

**9.2.1作用域和链接**

作用域(scope) 描述了名称在文件(翻译单元)的多大范围内可见。例如，函数中定义的变量可在该函数中使用，但不能在其他函数中使用；而在文件中的函数定义之前定义的变量则可在所有函数中使用。

链接性(linkage) 描述了名称如何在不同单元间共享。链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它们不能共享。

C++变量的作用域有多种。

作用域为局部的变量只在定义它的代码块中可用。代码块是由花括号括起的一系列语句。例如函数体就是代码块，但可以在函数体中嵌入其他代码块。

作用域为全局(也叫文件作用域)的变量在定义位置到文件结尾之间都可用。

自动变量的作用域为局部，静态变量的作用域是全局还是局部取决于它是如何被定义的。

在函数原型作用域( function prototype scope)中使用的名称只在包含参数列表的括号内可用(这就是为什么这些名称是什么以及是否出现都不重要的原因)。

在类中声明的成员的作用域为整个类(参见第10章)。

在名称空间中声明的变量的作用域为整个名称空间(由于名称空间已经引入到C++语言中，因此全局作用域是名称空间作用域的特例)。

C++函数的作用域可以是整个类或整个名称空间(包括全局的)，但不能是局部的(因为不能在代码块内定义函数，如果函数的作用域为局部，则只对它自己是可见的，因此不能被其他函数调用。这样的函数将无法运行)。

不同的C++存储方式是通过存储持续性、作用域和链接性来描述的。下面来看看各种C++存储方式的这些特征。首先介绍引入名称空间之前的情况，然后看名称空间带来的影响。

###### 9.2.2自动存储持续性

在默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。

也就是说，如果在main( )中声明了一个名为texas的变量，并在函数oil( )中也声明了-一个名为texas变量，则创建了两个独立的变量。只有在定义它们的函数中才能使用它们。对oil( )中的texas执行的任何操作都不会影响main( )中的texas，反之亦然。

另外，当程序开始执行这些变量所属的代码块时，将为其分配内存；当函数结束时，这些变量都将消失(注意，执行到代码块时，将为变量分配内存，但其作用域的起点为其声明位置)。

如果在代码块中定义了变量，则该变量的存在时间和作用域将被限制在该代码块内。

**全局变量与局部变量**

既然可以选择使用全局变量或局部变量，那么到底应使用哪种呢?首先，全局变量很有吸引力因 为所有的函数能访问全局变量，因此不用传递参数。但易于访问的代价很大一程序不可靠。 

计算经验表明，程序越能避免对数据进行不必要的访问，就越能保持数据的完整性。通常情况下，应使用局部变量,应在需要知晓时才传递数据，而不应不加区分地使用全局变量来使数据可用。

读者将会看到，OOP在数据隔离方面又向前迈进了一步。然而，全局变量也有它们的用处。例如，可以让多个函数可以使用同一个数据块(如月份名数组或原子量数组)。

外部存储尤其适于表示常量数据，因为这样可以使用关键字const 来防止数据被修改。

```c++
const char * const months [12] = 
{
	"January", "February", "March"， "April", "May",
	"June", "July", "August", "September", "October",
	"November", "December"
};
```

在上述示例中，第一个const防止字符串被修改，第二个const确保数组中每个指针始终指向它最初指向的字符串。



##### 9.3 名称空间

声明区域(declaration region) ：是可以在其中进行声明的区域。例如，可以在函数外声明全局变量，其声明区域为其声明所在的文件。对于在函数中声明的变量，其声明区域为其声明所在的代码块。

潜在作用域(potential scope)：从声明点开始，到其声明区域的结尾。

C++通过定义一种新的声明区域来创建命名的空间名称，目的是提供一个声明的区域，一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。

如何访问名称空间的名称，通过作用域解析运算符::

```c++
Jack::pail = 12.34;
Jill::Hill mole;
Jack::fetch();
```

**1.using声明和using编译指令**
我们并不希望每次使用名称时都对它进行限定，因此C++提供了两种机制(using声明和using编译指令)来简化对名称空间中名称的使用。

using声明使特定的标识符可用，using编译指令使整个名称空间可用。using声明由被限定的名称和它前面的关键字using组成:

```c++
using Jill::fetch;// a using declaration
```

using声明将特定的名称添加到它所属的声明区域中。例如main( )中的using声明`Jill::fetch`将fetch 添加到main( )定义的声明区域中。完成该声明后，便可以使用名称fetch 代替`Jill::fetch`。



##### 9.4 总结

C+ +鼓励程序员在开发程序时使用多个文件。一种有效的组织策略是，使用头文件来定义用户类型，为操纵用户类型的函数提供函数原型;并将函数定义放在一个独立的源代码文件中。头文件和源代码文件一起定义和实现了用户定义的类型及其使用方式。

最后，将main( )和其他使用这些函数的函数放在第三个文件中。

C++的存储方案决定了变量保留在内存中的时间(储存持续性)以及程序的哪一部分可以访问它(作用域和链接性)。自动变量是在代码块(如函数体或函数体中的代码块)中定义的变量，仅当程序执行到包含定义的代码块时，它们才存在，并且可见。自动变量可以通过使用存储类型说明符register 或根本不使用说明符来声明，没有使用说明符时，变量将默认为自动的。register 说明符提示编译器，该变量的使用频率很高，但C++11 摒弃了这种用法。

静态变量在整个程序执行期间都存在。对于在函数外面定义的变量，其所属文件中位于该变量的定义后面的所有函数都可以使用它(文件作用域)，并可在程序的其他文件中使用(外部链接性)。

另一个文件要使用这种变量，必须使用extern关键字来声明它。对于文件间共享的变量，应在一个文件中包含其定义声明(无需使用extern, 但如果同时进行初始化，也可使用它)，并在其他文件中包含引用声明(使用extern且不初始化)。

在函数的外面使用关键字static 定义的变量的作用域为整个文件,但是不能用于其他文件(内
部链接性)。在代码块中使用关键字static 定义的变量被限制在该代码块内( 局部作用域、无链接性)，但在整个程序执行期间，它都一直存在并且保持原值。

在默认情况下，C++函数的链接性为外部，因此可在文件间共享;但使用关键字static限定的函数的链接性为内部的，被限制在定义它的文件中。

动态内存分配和释放是使用new和delete进行的，它使用自由存储区或堆来存储数据。调用new占用内存，而调用delete释放内存。程序使用指针来跟踪这些内存单元。

名称空间允许定义一个可在其中声明标识符的命名区域。这样做的目的是减少名称冲突，尤其当程序非常大，并使用多个厂商的代码时。可以通过使用作用域解析运算符、using 声明或using编译指令，来使名称空间中的标识符可用。