##### 7.3 函数和数组

```c++
int sum_arr(int arr[], int n); //arr = array name, n = size
```

arr实际上并不是数组，而是一个指针！

但在编写函数的其余部分时，可以将arr看作是数组。

**函数如何使用指针来处理数组**：

在大多数情况下，C++和C语言一样，也将数组名视为指针。第4章介绍过，C++将数组名解释为其第一个元素的地址:

```c++
cookies = &cookies[0] // array name is address of first element
```

该规则有一些例外。

- 首先，数组声明使用数组名来标记存储位置；
- 其次，对数组名使用`sizeof`将得到整个数组的长度(以字节为单位；
- 第三，正如第4章指出的，将地址运算符&用于数组名时，将返回整个数组的地址，例如&cookies将返回一个32字节内存块的地址(如果int长4字节)。

程序清单7.5执行下面的函数调用:

```c++
int sum = sum_ arr(cookies, ArSize) ;
```

其中，cookies 是数组名，而根据C++规则，cookies 是其第一个元素的地址，因此函数传递的是地址。

由于数组的元素的类型为int, 因此cookies的类型必须是int指针，即int*。这表明，正确的函数头应该是这样的:

```c++
int sum_arr(int * arr, int n) // arr = array name, n = size
```

其中用`int* arr`替换了`int arr[]`。

这证明这两个函数头都是正确的，因为在C++中，**当(且仅当)用于函数头或函数原型中，`int *arr`和`int arr [ ]`的含义才是相同的**。它们都意味着arr是一个int指针。

然而，数组表示法(int arr[])提醒用户，arr不仅指向int，还指向int 数组的第一个int。

当指针指向数组的第一个元素时，本书使用数组表示法：而当指针指向一个独立的值时，使用指针表示法。

别忘了，在其他的上下文中，`int* arr`和`int arr[]`的含义并不相同。

鉴于变量arr实际上就是一个指针，函数的其余部分是合理的。

第4章在介绍动态数组时指出过，同数组名或指针一样，也可以用方括号数组表示法来访问数组元素。

无论arr 是指针还是数组名，表达式arr [3]都指的是数组的第4个元素。就目前而言，提请读者记住下面两个恒等式，将不会有任何坏处:

```c++
arr[i] == *(ar + i) 	// values in two notations
&arr[i] ==ar+ i 	// addresses in two notations
```

记住，将指针(包括数组名)加1, 实际上是加上了一个与指针指向的类型的长度(以字节为单位)相等的值。对于遍历数组而言，使用指针加法和数组下标是等效的。

注意：**接受数组名参数的函数访问的是原始数组**

可以使用const使传入的数组为只读数据。

**尽可能使用const**

将指针参数声明为指向常量数据的指针有两条理由:

- 这样可以避免由于无意间修改数据而导致的编程错误;
- 使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。

如果条件允许，则应将指针形参声明为指向const的指针。



##### 7.6.3 传递结构的地址

假设要传递结构的地址而不是整个结构以节省时间和空间，则需要重新编写前面的函数，使用指向结构的指针。首先来看一-看如何重新编写show_ polar( )函数。需要修改三个地方:

- 调用函数时， 将结构的地址(&pplace) 而不是结构本身(pplace) 传递给它;
- 将形参声明为指向 polar的指针，即polar *类型。由于函数不应该修改结构，因此使用了const 修饰符;
- 由于形参是指针而不是结构，因此应间接成员运算符(->)， 而不是成员运算符(句点)。

```c++
//传递结构的地址
void show_polar2(const polar * pda) {
    using namespace std;
    const double Rad_to_deg = 57.29577951;

    cout << "distance = " << pda->distance;
    cout << ", angle = " << pda->angle * Rad_to_deg;
    cout << " degrees\n";
}
```

