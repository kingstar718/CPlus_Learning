##### 8.2 引用变量

引用是已定义的变量的别名。

引用变量的主要用途是作函数的形参。引用变量用作参数，函数将使用原始数据，而不是其副本。

C和C++使用&来指示变量的地址。C++给&符号赋予了新的含义，将其用来声明引用。

```c++
int rats；
int & rodents = rates; // makes rodents an alias rats 
```

其中，&不是地址运算符，而是类型标识符的一部分。

上述引用声明允许将rats和rodents互换一它们指向相同的值和内存单元。



```c++
int rats = 101;
int & rodents = rats; // rodents a reference
int * prats = &rats; // prats a pointer
```

这样，表达式`rodents`和`*prats`都可以同`rats`互换，而表达式`&rodents`和`prats` 都可以同`&rats`互换。

从这一点来说，引用看上去很像伪装表示的指针(其中，*解除引用运算符被隐式理解)。

实际上，引用还是不同于指针的。除了表示法不同外，还有其他的差别。

例如，差别之一是， 必须在声明引用时将其初始化，而不能像指针那样，先声明，再赋值:

```c++
int rat;
int & rodent;
rodent = rat; // No, you can't do this
```

注意：**必须在声明引用变量时进行初始化**。

引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。也就是说:

```c++
int & rodents = rats;
```

实际上是下述代码的伪装表示:

```c++
int * const pr = &rats;
```

其中，引用rodents扮演的角色与表达式*pr相同。



**何时使用引用**

使用引用参数的主要原因有两个。

- 程序员能够修改调用函数中的数据对象。
- 通过传递引用而不是整个数据对象，可以提高程序的运行速度。

当数据对象较大时(如结构和类对象)，第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另-一个接口。那么，什么时候应使用引用、什么时候应使用指针呢?什么时候应按值传递呢?下面是一 些指导原则:

对于使用传递的值而不作修改的函数。

- 如果数据对象很小， 如内置数据类型或小型结构，则按值传递。
- 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。
- 如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。
- 如果数据对象是类对象， 则使用const引用。**类设计的语义常常要求使用引用**，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。

对于修改调用函数中数据的函数:

- 如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit (&x)这样的代码(其中x是int)，则很明显，该函数将修改x。
- 如果数据对象是数组，则只能使用指针。
- 如果数据对象是结构，则使用引用或指针。
- 如果数据对象是类对象，则使用引用。

当然，这只是一些指导原则，很可能有充分的理由做出其他的选择。例如，对于基本类型，cin 使用引用，因此可以使用cin>>n， 而不是cin >> &n。



##### 8.5 函数模板

函数模板是通用的函数描述，即它们使用泛型来定义函数，其中的泛型可以用具体的类型替换。